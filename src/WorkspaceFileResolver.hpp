#pragma once
#include <optional>
#include <unordered_map>

// Get the corresponding Luau module name for a file
Luau::ModuleName getModuleName(const std::string& name)
{
    return name;
}
Luau::ModuleName getModuleName(const std::filesystem::path& name)
{
    return name.generic_string();
}
Luau::ModuleName getModuleName(const Uri& name)
{
    return name.fsPath().generic_string();
}

struct WorkspaceFileResolver
    : Luau::FileResolver
    , Luau::ConfigResolver
{
    Luau::Config defaultConfig;

    // The root source node from a parsed Rojo source map
    lsp::DocumentUri rootUri;
    SourceNodePtr rootSourceNode;
    mutable std::unordered_map<std::string, SourceNodePtr> realPathsToSourceNodes;
    mutable std::unordered_map<Luau::ModuleName, SourceNodePtr> virtualPathsToSourceNodes;

    // Currently opened files where content is managed by client
    mutable std::unordered_map<Luau::ModuleName, TextDocument> managedFiles;
    mutable std::unordered_map<std::string, Luau::Config> configCache;
    mutable std::vector<std::pair<std::filesystem::path, std::string>> configErrors;

    WorkspaceFileResolver()
    {
        defaultConfig.mode = Luau::Mode::Nonstrict;
    }

    /// The file is managed by the client, so FS will be out of date
    bool isManagedFile(const Luau::ModuleName& name) const
    {
        return managedFiles.find(name) != managedFiles.end();
    }

    /// The name points to a virtual path (i.e., game/ or ProjectRoot/)
    bool isVirtualPath(const Luau::ModuleName& name) const
    {
        return name == "game" || name == "ProjectRoot" || Luau::startsWith(name, "game/") || Luau::startsWith(name, "ProjectRoot");
    }

    std::optional<SourceNodePtr> getSourceNodeFromVirtualPath(const Luau::ModuleName& name) const
    {
        if (virtualPathsToSourceNodes.find(name) == virtualPathsToSourceNodes.end())
            return std::nullopt;
        return virtualPathsToSourceNodes.at(name);
    }

    std::optional<SourceNodePtr> getSourceNodeFromRealPath(const std::string& name) const
    {
        std::error_code ec;
        auto canonicalName = std::filesystem::canonical(name, ec);
        if (ec.value() != 0)
            canonicalName = name;
        auto strName = canonicalName.generic_string();
        if (realPathsToSourceNodes.find(strName) == realPathsToSourceNodes.end())
            return std::nullopt;
        return realPathsToSourceNodes.at(strName);
    }

    Luau::ModuleName getVirtualPathFromSourceNode(const SourceNodePtr& sourceNode) const
    {
        return sourceNode->virtualPath;
    }

    std::optional<Luau::ModuleName> resolveToVirtualPath(const std::string& name) const
    {
        if (isVirtualPath(name))
        {
            return name;
        }
        else
        {
            auto sourceNode = getSourceNodeFromRealPath(name);
            if (!sourceNode)
                return std::nullopt;
            return getVirtualPathFromSourceNode(sourceNode.value());
        }
    }

    std::optional<std::filesystem::path> resolveVirtualPathToRealPath(const Luau::ModuleName& name) const
    {
        if (auto sourceNode = getSourceNodeFromVirtualPath(name))
        {
            // NOTE: this filepath is generated by the sourcemap, which is relative to the cwd where the sourcemap
            // command was run from. Hence, we concatenate it to the end of the workspace path
            // TODO: make sure this is correct once we make sourcemap.json generic
            auto filePath = sourceNode.value()->getScriptFilePath();
            if (filePath)
                return rootUri.fsPath() / *filePath;
            return std::nullopt;
        }
        return std::nullopt;
    }

    std::optional<Luau::SourceCode> readSource(const Luau::ModuleName& name) override
    {
        Luau::SourceCode::Type sourceType = Luau::SourceCode::Module;
        std::optional<std::string> source;

        std::filesystem::path realFileName = name;
        if (isVirtualPath(name))
        {
            auto sourceNode = getSourceNodeFromVirtualPath(name);
            if (!sourceNode)
                return std::nullopt;
            auto filePath = sourceNode.value()->getScriptFilePath();
            if (!filePath)
                return std::nullopt;
            realFileName = filePath.value();
            sourceType = sourceNode.value()->sourceCodeType();
        }
        else
        {
            sourceType = sourceCodeTypeFromPath(realFileName);
        }

        if (isManagedFile(name))
        {
            source = managedFiles.at(name).getText();
        }
        else
        {
            source = readFile(realFileName);
            if (source && realFileName.extension() == ".json")
            {
                try
                {
                    source = "--!strict\nreturn " + jsonValueToLuau(json::parse(*source));
                }
                catch (const std::exception& e)
                {
                    // TODO: display diagnostic?
                    std::cerr << "Failed to load JSON module: " << realFileName.generic_string() << " - " << e.what() << std::endl;
                    return std::nullopt;
                }
            }
        }

        if (!source)
            return std::nullopt;

        return Luau::SourceCode{*source, sourceType};
    }

    std::optional<Luau::ModuleInfo> resolveModule(const Luau::ModuleInfo* context, Luau::AstExpr* node) override
    {
        // Handle require("path") for compatibility
        if (Luau::AstExprConstantString* expr = node->as<Luau::AstExprConstantString>())
        {
            Luau::ModuleName name = std::string(expr->value.data, expr->value.size) + ".luau";
            if (!readFile(name))
            {
                // fall back to .lua if a module with .luau doesn't exist
                name = std::string(expr->value.data, expr->value.size) + ".lua";
            }

            return {{name}};
        }
        else if (Luau::AstExprGlobal* g = node->as<Luau::AstExprGlobal>())
        {
            if (g->name == "game")
                return Luau::ModuleInfo{"game"};

            if (g->name == "script")
            {
                if (auto virtualPath = resolveToVirtualPath(context->name))
                {
                    return Luau::ModuleInfo{virtualPath.value()};
                }
            }
        }
        else if (Luau::AstExprIndexName* i = node->as<Luau::AstExprIndexName>())
        {
            if (context)
            {
                if (strcmp(i->index.value, "Parent") == 0)
                {
                    // Pop the name instead
                    auto parentPath = getParentPath(context->name);
                    if (parentPath.has_value())
                        return Luau::ModuleInfo{parentPath.value(), context->optional};
                }

                return Luau::ModuleInfo{context->name + '/' + i->index.value, context->optional};
            }
        }
        else if (Luau::AstExprIndexExpr* i_expr = node->as<Luau::AstExprIndexExpr>())
        {
            if (Luau::AstExprConstantString* index = i_expr->index->as<Luau::AstExprConstantString>())
            {
                if (context)
                    return Luau::ModuleInfo{context->name + '/' + std::string(index->value.data, index->value.size), context->optional};
            }
        }
        else if (Luau::AstExprCall* call = node->as<Luau::AstExprCall>(); call && call->self && call->args.size >= 1 && context)
        {
            if (Luau::AstExprConstantString* index = call->args.data[0]->as<Luau::AstExprConstantString>())
            {
                Luau::AstName func = call->func->as<Luau::AstExprIndexName>()->index;

                if (func == "GetService" && context->name == "game")
                    return Luau::ModuleInfo{"game/" + std::string(index->value.data, index->value.size)};
                if (func == "WaitForChild" || func == "FindFirstChild")
                    if (context)
                        return Luau::ModuleInfo{context->name + '/' + std::string(index->value.data, index->value.size), context->optional};
            }
        }

        return std::nullopt;
    }

    std::string getHumanReadableModuleName(const Luau::ModuleName& name) const override
    {
        if (isVirtualPath(name))
        {
            if (auto realPath = resolveVirtualPathToRealPath(name))
            {
                return realPath->relative_path().generic_string() + " [" + name + "]";
            }
            else
            {
                return name;
            }
        }
        else
        {
            return name;
        }
    }

    const Luau::Config& getConfig(const Luau::ModuleName& name) const override
    {
        std::optional<std::filesystem::path> realPath = name;
        if (isVirtualPath(name))
        {
            realPath = resolveVirtualPathToRealPath(name);
        }

        if (!realPath || !realPath->has_relative_path() || !realPath->has_parent_path())
            return defaultConfig;

        return readConfigRec(realPath->parent_path());
    }

    const Luau::Config& readConfigRec(const std::filesystem::path& path) const
    {
        auto it = configCache.find(path.generic_string());
        if (it != configCache.end())
            return it->second;

        Luau::Config result = (path.has_relative_path() && path.has_parent_path()) ? readConfigRec(path.parent_path()) : defaultConfig;
        auto configPath = path / Luau::kConfigName;

        if (std::optional<std::string> contents = readFile(configPath))
        {
            std::optional<std::string> error = Luau::parseConfig(*contents, result);
            if (error)
                configErrors.push_back({configPath, *error});
        }

        return configCache[path.generic_string()] = result;
    }

    void writePathsToMap(const SourceNodePtr& node, const std::string& base)
    {
        node->virtualPath = base;
        virtualPathsToSourceNodes[base] = node;

        if (auto realPath = node->getScriptFilePath())
        {
            std::error_code ec;
            auto canonicalName = std::filesystem::canonical(*realPath, ec);
            if (ec.value() != 0)
                canonicalName = *realPath;
            realPathsToSourceNodes[canonicalName.generic_string()] = node;
        }

        for (auto& child : node->children)
        {
            writePathsToMap(child, base + "/" + child->name);
        }
    }

    void updateSourceMap(const std::string& sourceMapContents)
    {
        realPathsToSourceNodes.clear();
        virtualPathsToSourceNodes.clear();

        try
        {
            auto j = json::parse(sourceMapContents);
            rootSourceNode = std::make_shared<SourceNode>(j.get<SourceNode>());

            // Write paths
            std::string base = rootSourceNode->className == "DataModel" ? "game" : "ProjectRoot";
            writePathsToMap(rootSourceNode, base);
        }
        catch (const std::exception& e)
        {
            // TODO: log message?
            std::cerr << e.what() << std::endl;
        }
    }
};